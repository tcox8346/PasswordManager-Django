from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser, UserManager, PermissionsMixin
#Mail Functionality
from django.core.mail import send_mail
import datetime
from .tokens import TokenGenerator
#import 

KEY_SIZE = 64


# Create your models here.


class SolutionUserManager(UserManager):
    def _create_user(self, email, username, password, **extra_fields):
        if not email:
            raise ValueError("Email is required")
        email = self.normalize_email(email)
        user = self.model(email = email,username = username,**extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        
        return user
    
    def create_user(self, email=None, username=None, password=None, **extra_fields):
        extra_fields.setdefault('is_superuser', False)
        extra_fields.setdefault('is_staff', False)
        return self._create_user(email,username, **extra_fields)
    
    def create_superuser(self, email=None, username=None, **extra_fields):
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_active', True)
        return self._create_user(email,username, **extra_fields)
    
class SolutionUser(AbstractUser, PermissionsMixin):
    #For this solution the user password is instead a key automatically generated by the system upon registration which is sent to the user
    username = models.CharField(max_length=255, blank=False, unique=True, null=True)
    email = models.EmailField(blank=False, unique=False, default="")
    #TODO- at a later date implement way to remove need for this field 
    password = models.CharField(max_length=KEY_SIZE, blank=False, unique=False, null=True)
    #password == master key of user, created by system upon registration
    key = models.CharField(max_length=KEY_SIZE, blank=False, unique=True, null=True)
    #control attribute - disabled when account is first logged in - deactivated when creating initial key
    is_new = models.BooleanField(default=True)
    is_active = models.BooleanField(default=False)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    date_joined = models.DateTimeField(auto_now=False, auto_now_add=True) 
    slug = models.SlugField(default='', null=False)
    

    #Constraints  
    models.UniqueConstraint(fields=['username', 'email'], name= 'unique_account')
    
    
    #Authentication 
    USERNAME_FIELD = 'username'
    EMAIL_FIELD = 'email'
    REQUIRED_FIELDS = ['email']
    
    objects = SolutionUserManager()
    
    def __str__(self):
        return f"{self.username} {self.email}"
    def _create_masterkeys(self, size):
        #@ method that creates and returns a random key of a specific length, KEY_SIZE
        try:
            #generate 2 keys and return values when not matching
            key1 = UserManager.make_random_password(size).join(str(self.email))
            key2 = UserManager.make_random_password(size).join(str(self.email))
           
            while key1 == key2:            
                key1 = UserManager.make_random_password(size).join(str(self.email))
                key2 = UserManager.make_random_password(size).join(str(self.email))
            return (key1,key2)
        except:
            print('An Error has occured while creating a new key')
            return None
    def create_masterkey(self):
        return self._create_masterkeys(KEY_SIZE)
    def email_user(self, subject: str, message: str,recipient_list: list,from_email: str = ..., **kwargs):
        send_mail(message=message, subject=subject, from_email=from_email, recipient_list=recipient_list)
        return 
    def create_profile(self):
        if not SolutionUserProfile.objects.filter(user=self).exists():
            user_profile =  SolutionUserProfile(user=self)
            user_profile.save()
            return user_profile
        else:
            print("\n User Profile Exists \n")
        return SolutionUserProfile.objects.filter(user=self).get()
    def set_uniqueidentifier(self):
        
        most_recent = self.objects.latest(field_name = 'unique_identifier')
        if most_recent:
            try:
                new_identifier = most_recent + 1
                self.unique_identifier = new_identifier
                print(f'New identifier assigned {new_identifier}')
            except:
                print("An error has occured")
        return
    
        
        
#TODO setup user profile, users activly interact with this object only, have no direct acces to SolutionUser.
#This solution is innitially created when the user first signs in to the solution.     
class SolutionUserProfile(models.Model):
    user = models.ForeignKey(get_user_model(), related_name='profile_owners', on_delete=models.CASCADE)
    image = models.ImageField(blank=True,upload_to=None, height_field=20, width_field=20, max_length=None)
    session_key = models.CharField(null=True, max_length=50) # Encrpytion key provided by user that encrpyts/decrypts their credentials //TODO

    def get_absolute_url(self):
        return f"{self.user.username}/profile/"
    def update_key(self, value):
        self.session_key = value  
        print(f'user: {self.user.get_username()} has updated their session key')  
        return 
    def update_image(self,image):
        #type check image, only allow jpg for testing
        self.image = image
        print(f'user: {self.user.get_username()} has updated their session key')  
        return    
    
class Token(models.Model):
    tokenValue = models.CharField(max_length=50, blank = True, null = True)
    owner = models.ForeignKey(get_user_model(), verbose_name=("TokenOwner"), on_delete=models.CASCADE)
    activeState = models.IntegerField(default=0, blank = True)
    activeTimeFrame = models.DurationField(null = True, default = datetime.timedelta(hours=10))
    
    ActiveStates = {"useable": 0, "used": 1}
    def deactivateToken(self):
        self.active = self.ActiveState["useable"]
    def activateToken(self):
        self.active = self.ActiveState["used"]
    def generateToken(self):
        #Create a token of x length
        self.tokenValue = TokenGenerator(self.owner)
    def bisValid(self):
        if (datetime.datetime.now() - self.activeTimeFrame) <= 10:
            return True
        return False
        
    