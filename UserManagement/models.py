
from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AbstractUser, UserManager, PermissionsMixin
#Mail Functionality
from django.core.mail import send_mail
# Token generation
from .tokens import TokenGenerator
# REquired functions
import re, secrets, datetime
from django.urls import reverse
from django.db.models import Q

# Validation Requirements
from django.core.exceptions import ValidationError

#Find way to implement safe guard for importing

#modules_to_import = [re]
#for module in modules_to_import:
#    if module not in sys.modules:
#        import module

#Global Constants
KEY_SIZE = 256

#Validators 
def validate_requesttarget(value):
    request_target_user = get_user_model().objects.filter(username = value)
    if not SolutionUserProfile.objects.filter(request_target_user).exists() :
        raise ValidationError(("%(value) is does not exists"), params={"value": value})     
    

# models
class SolutionUserManager(UserManager):
    def _create_user(self, email, username, password, **extra_fields):
        if not email:
            raise ValueError("Email is required")
        email = self.normalize_email(email)
        if not username:
            raise ValueError("username is required")
        user = self.model(email = email,username = username,**extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        
        return user
    
    def create_user(self, email=None, username=None, password=None, **extra_fields):
        extra_fields.setdefault('is_superuser', False)
        extra_fields.setdefault('is_staff', False)
        return self._create_user(email,username, **extra_fields)
    
    def create_superuser(self, email=None, username=None, **extra_fields):
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_active', True)
        return self._create_user(email,username, **extra_fields)
    
class SolutionUser(AbstractUser, PermissionsMixin):
    #For this solution the user password is instead a key automatically generated by the system upon registration which is sent to the user
    username = models.CharField(max_length=255, blank=False, unique=True, null=True) # seen by users - cannot be changed 
    email = models.EmailField(blank=False, unique=False, default="")
    #TODO- at a later date implement way to remove need for this field 
    password = models.CharField(max_length=1024, blank=False, unique=False, null=True)

    #password == master key of user, created by system upon registration - this value is a hash of the users actual key and used to confirm user defined master key
    key = models.CharField(max_length=KEY_SIZE, blank=False, unique=True, null=True)
    
    #control attribute - disabled when account is first logged in - deactivated when creating initial key
    is_new = models.BooleanField(default=True)
    is_active = models.BooleanField(default=False)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    date_joined = models.DateTimeField(auto_now=False, auto_now_add=True) 
    slug = models.SlugField(default='', null=False)
    
    #Constraints  
    models.UniqueConstraint(fields=['username', 'email'], name= 'unique_account')
    
    #Authentication 
    USERNAME_FIELD = 'username'
    EMAIL_FIELD = 'email'
    REQUIRED_FIELDS = ['email',]
    objects = SolutionUserManager()
    
    def __str__(self):
        return f"{self.username} {self.email}"
    def _create_key(self, size):
        #@ method that creates and returns a random key of a specific length, KEY_SIZE
        try:
            
            # generate a new key combo that is unique
            secret_key = self.generate_free_key()

            counter = 0 
            while SolutionUser.objects.filter(key=secret_key).exists() and counter < 5:
                # This version uses a randomly generated string of key_size length
                secret_key = secrets.token_hex(KEY_SIZE)
                counter += 1          
            
            print("new key generated")
            return secret_key
        except Exception as ex:
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            return None
    def create_masterkey(self):
        return self._create_key(KEY_SIZE)  
    def generate_free_key(self, key_size = KEY_SIZE):
        # generate a new key combo that is unique
        return secrets.token_hex(key_size)
  
    def email_user(self, subject: str, message: str,recipient_list: list,from_email: str = ..., **kwargs):
        send_mail(message=message, subject=subject, from_email=from_email, recipient_list=recipient_list)
        return 
    def create_profile(self,user_account ,key_size = KEY_SIZE):
        # Check if profile already exists
        if SolutionUserProfile.objects.filter(user=self).exists():
            return False
            
        #Generate a possible share key 
        share_key= self.generate_free_key(key_size)  
                
        #create  counters for retrying to create unique key
        counter = 0
        counter_limit = 10
        # Check if generated key is unique to SolutionUserProfile Table, if not redo up to x times
        while SolutionUserProfile.objects.filter(shared_key = share_key).exists():
            print("Shared Key Found in Record")
            if counter >= counter_limit:
                print("Counter limit reached, unable to create a profile")
                return False  
            
            counter += 1
            share_key= self.generate_free_key(key_size)
    
        # Create and Save profile record 
        new_profile = SolutionUserProfile.objects.create(user = user_account, shared_key = share_key)
        new_profile.save()
       
        return True
        
class Token(models.Model):
    tokenValue = models.CharField(max_length=50, blank = True, null = True, unique=True)
    owner = models.ForeignKey(get_user_model(), verbose_name=("TokenOwner"), on_delete=models.CASCADE)
    activeState = models.IntegerField(default=0, blank = True)
    activeTimeFrame = models.DurationField(null = True, default = datetime.timedelta(hours=10))
    
    ActiveStates = {"useable": 0, "used": 1}
    def deactivateToken(self):
        self.active = self.ActiveState["useable"]
    def activateToken(self):
        self.active = self.ActiveState["used"]
    def generateToken(self):
        #Create a token of x length
        try:
            newToken = TokenGenerator(self.owner)
            self.tokenValue = newToken
        except Exception:
            print("A Token has been generated that already exists")
            
            for i in range(5):
                newToken = TokenGenerator(self.owner)
                result = Token.objects.filter(tokenValue = newToken).exists()
                if not result:
                    self.tokenValue = newToken
                    return
            print(f"A New Token Value unable to be created for user {self.owner.username}")
        return
    def bisValid(self):
        # TODO - Impemenent time based validity checking - activeTimeFrame : latest date-time in which token is implicitly valid
        if self.active == 0:
            return True
        return False
    def reset_token(self):
       
        try:
            # create new tokenValue, distinct
            self.generateToken()
            # Change token state to usable
            self.deactivateToken()
            # Send email containing new token and link to users email
        
        except Exception:
            pass
        return
 
   
class SolutionUserProfile(models.Model):
    user = models.ForeignKey(get_user_model(), related_name='profile_owners', on_delete=models.CASCADE)
    image = models.ImageField(blank=True,upload_to=None, height_field=20, width_field=20, max_length=None)
    friend_list = models.CharField(blank=True, max_length=500, default='') # Field encrypted by user master key, csv of friends . "friendname,friendname,...""
    shared_key = models.CharField(blank=True, default='', max_length=KEY_SIZE) # A Encryption key used to encrypt and decrypt Credential Records marked as shared by the user, 256 byte key
    shared_keys = models.CharField(blank=False, default= "", max_length=2056) # A Dictionary in csv form . example : "username=value, username=value,..."
    
    def get_absolute_url(self):
        return f"{self.user.username}/profile/"

    def update_image(self,image):
        #type check image, only allow jpg for testing - Must be filtered to allow files up to a safe size with no sql code
        self.image = image
        print(f'user: {self.user.get_username()} has updated their session key')  
        return    
    #All methods work on the assumption that the input is a string value
    def add_friend(self, new_friend:str):
        # check if user isn't already a friend
        if not self.check_friends(new_friend):
            # get current friends as a list
            friends_list:list = self.get_friends_list(self)
            # add new friend to list
            friends_list.append(new_friend)
            
            # set friends list to new friends list csv
            self.set_friends_list_as_csv(friends_list)
            
            #Save changes
            self.save()
            
        return 
    def remove_friend(self, old_friend:str):

        # get current friends list as list
        friends_list:list = self.get_friends_list()
        
        # remove old friend username from list
        friends_list.remove(old_friend) 
        
        #convert updated list into csv 
        updated_list_as_csv = self.convert_list_to_csv(friends_list)
        self.set_friends_list_as_csv(updated_list_as_csv)  
        
        return 
    def check_friends(self,new_friend_username:str):
        """Returns True if friend object is already in friends list"""
        # Returns True if new friend already in friends list
        if new_friend_username in self.get_friends_list():
            return True
        #if not return False
        return False
    def get_friends_list(self):
        """Returns friends list in list form, list of usernames:strings"""
        return self.convert_csv_to_list(self.friend_list)
    def set_friends_list_as_csv(self, new_list:list):
        """saves friends list in csv form"""
        self.friend_list = self.convert_list_to_csv(new_list)
        
        self.save()
        return 
    def convert_list_to_csv(self, friends_list:str):
        """Convert list into csv string, list taken in must not have values with trailing commas"""
        # Get csv stringified list
        friends_csv:str = ''
        #convert new corewords list into csv
        for friend in friends_list:
            friends_csv += friend + ','
        return friends_csv  
    def convert_csv_to_list(self, csv):
        csv_to_list = re.split(',',csv)
        return list(filter(None, csv_to_list))
    def convert_dict_to_csv(self, dictonary:dict):
        """Converts a dictionary into a csv string: key : value to 'key=value,...' """
        csv_version:str = ''
        for key in dictonary.keys():
            # append each result of 'key=value,' to csv version result
            csv_version += f'{key}={dictonary.get(key)},'
            
        return csv_version
    def add_shared_key(self, friend_profile):
        # if name is in friends list 
        if friend_profile.user.username in self.get_friends_list():
            # Get Shared Keys dictionary
            shared_keys = self.get_shared_keys_dict()
            #if friend already in dictionary - do nothing as this implementation doesnt have the ability to change a accounts share keys
            if friend_profile.user.username in shared_keys.keys():
                return
            
            #   otherwise add friend username as key and friend share key as value
            shared_keys.update({friend_profile.user.username: friend_profile.shared_key})
            
            # update profiles shared keys dictionary-csv list to updated 
            self.save()
        return 0
    def _remove_shared_key(self, friend_profile):
        """Removes shared key from friends list: Testing implementation gets friends list csv as list, removes list object  which is in the form of ['key=value',], removing a shared key means removing a friend from friendlist"""
        # Get current friends list 
        friends_list = self.get_friends_list()
        #Iterate through friends list to find friend object
        for friend_object in friends_list:
             #if friend profile in friends list
            if friend_profile.user.username == friend_object:
                #remove list object from list
                friends_list.remove(friend_object)
        # Set shared keys to updated list in csv form
        self.set_friends_list_as_csv(friends_list)
        
        #save changes
        self.save()
        return  
    def get_shared_keys_dict(self):
        # Get shared key csv and convert to list 
        shared_keys_list = self.convert_csv_to_list(self.shared_keys) # This implementation takes csv string form "key=value," and converts it into a list of "key=value"
        # create a dictionary object for each listed object
        friends_dict:dict = {}
        # iterate through list and cr
        for object in shared_keys_list:
            # store key, value and current use of tokens
            key = ''
            value = ''
            current_subject = ''
            
            # store boolean that decides if tokens are for key or value
            key_value_switch = False
            for token in object:
                # if assigmnet token is reached assign key value to current string, 
                if token == "=" and not key_value_switch:
                    key = current_subject
                    # clear current tokens 
                    current_subject = ''
                    # flip switch to value mode
                    key_value_switch = True
                # else if delimitir token is reached 
                elif token == ',' and key_value_switch:
                    # assign value to current token string
                    value = current_subject
                    # flip to key mode
                    key_value_switch = False
                    # add key value pair to friends dictionary
                    friends_dict.update({key:value})
                    # clear all values to use for next value in csv
                    key, value, current_subject = ''
                
                # Add token to current string 
                current_subject += token         
        return friends_dict
    def generate_free_key(self):
        # generate a new key combo that is unique
        return secrets.token_hex(KEY_SIZE)
   
class FriendRequest(models.Model):
    requester = models.ForeignKey(SolutionUserProfile, related_name='requesting_user', on_delete=models.CASCADE) # Direct mapping to UserAccount entry
    request_target = models.ForeignKey(SolutionUserProfile, related_name='request_target', on_delete=models.CASCADE, validators=[validate_requesttarget])
    request_state = models.BooleanField(default=False, null=False) # State: active = 0 , inactive  = 1
    request_datetime = models.DateTimeField(auto_now_add=True)
    request_response = models.BooleanField(blank = True, null=True) # State: declined = 0 , accepted  = 1
    
    # Disallow repeat request for active request - TODO - set contraint to allow only one record with current constraint to be active at a time. 
        # This is to allow a user to request a friend again 
    class Meta:
        #unique together current constraint and request_state = False : active
        constraints = (models.UniqueConstraint(fields=['requester', 'request_target'], condition=Q(request_state=False), name="unique_freind_request"),)
        
       
    def get_absolute_url(self):
     return reverse("request_detail", kwargs={"pk": self.pk})
    
    # This classes functions all work on the premise of user profiles
    def process_request(self, is_accepted, current_user_profile:SolutionUserProfile):
        """Accepts a boolean and the user profile of the current user. \n Results in the manipulation of both the recipient and requesting user profiles friends list being updated if boolean is True"""
        if type(is_accepted) == bool and current_user_profile == self.request_target:
            #if the request has been accepted 
            self.request_response = is_accepted
            
            if is_accepted == True:
                try:
                    
                    recipient = current_user_profile
                    requester = self.requester
                    
                    # add username of requester to recipient friends list
                    recipient.add_friend(requester)
                
                    # add username of recipient to  requester friends list
                    requester.add_friend(recipient)
                
                   
                except Exception: 
                    print('An error has occured while modifying friendlist')
                    return 0
                
                
            # When completed change request to inactive
            try:
                self.request_response = is_accepted
                self.request_state = True
            
            except Exception:
                print('An error has occured while accessing or changing a friend request')
                return 0
            
            # If no errors have occured save the changes to the record
            self.save(commit=True)
            return 1
    def cancel_request(self, requester_profile:SolutionUserProfile):
        # if requester desires to cancel the friend request
        if requester_profile == self.requester:
            # set request state to inactive
            self.request_state = 1
        
        # save cancel state change
        self.save(commit = True)
        # return value designating operation success
        
        return 1
      
